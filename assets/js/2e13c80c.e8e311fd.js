"use strict";(self.webpackChunkupb_rustworkshop_github_io=self.webpackChunkupb_rustworkshop_github_io||[]).push([[1514],{8220:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"tauri/build-your-own-text-editor/showing-properties","title":"The System Inspector","description":"---","source":"@site/docs/tauri/2.build-your-own-text-editor/5.showing-properties.md","sourceDirName":"tauri/2.build-your-own-text-editor","slug":"/tauri/build-your-own-text-editor/showing-properties","permalink":"/docs/tauri/build-your-own-text-editor/showing-properties","draft":false,"unlisted":false,"editUrl":"https://github.com/UPB-RustWorkshop/upb-rustworkshop.github.io/edit/main/docs/tauri/2.build-your-own-text-editor/5.showing-properties.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"The System Inspector"},"sidebar":"tutorialSidebar","previous":{"title":"Create Files","permalink":"/docs/tauri/build-your-own-text-editor/create-files"},"next":{"title":"Next Challenges","permalink":"/docs/tauri/next-challenges"}}');var i=n(4848),r=n(8453);const o={title:"The System Inspector"},l="Task 4: The System Inspector",a={},d=[{value:"<strong>1. The Concept: Struct Serialization</strong>",id:"1-the-concept-struct-serialization",level:3},{value:"<strong>2. Backend Challenge (Rust)</strong>",id:"2-backend-challenge-rust",level:3},{value:"<strong>3. Frontend Challenge (TypeScript)</strong>",id:"3-frontend-challenge-typescript",level:3},{value:"<strong>4. Deep Dive: The Time Problem</strong>",id:"4-deep-dive-the-time-problem",level:3},{value:"<strong>Conclusion Task 4</strong>",id:"conclusion-task-4",level:3}];function c(e){const t={code:"code",em:"em",h1:"h1",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"task-4-the-system-inspector",children:"Task 4: The System Inspector"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.em,{children:'"Reading the text is simple. Reading the system attributes is where engineering begins."'})}),"\n",(0,i.jsxs)(t.p,{children:["In standard C/C++, accessing file metadata (size, permissions, timestamps) involves using the ",(0,i.jsx)(t.code,{children:"stat"})," family of structs and system calls, which can vary significantly between Windows and Linux/macOS."]}),"\n",(0,i.jsxs)(t.p,{children:["Rust abstracts this via ",(0,i.jsx)(t.code,{children:"std::fs::metadata"}),", but introduces a new challenge: ",(0,i.jsx)(t.strong,{children:"Data Serialization"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Your Mission:"}),' Add a "File Info" panel that displays system-level metadata for the currently open file.']}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"1-the-concept-struct-serialization",children:(0,i.jsx)(t.strong,{children:"1. The Concept: Struct Serialization"})}),"\n",(0,i.jsx)(t.p,{children:"To send a complex C-style struct from Rust to a JavaScript frontend, we cannot simply pass the memory address. We must serialize the data into a format the frontend understands (JSON)."}),"\n",(0,i.jsxs)(t.p,{children:["Rust uses a standard crate for this called ",(0,i.jsx)(t.strong,{children:"Serde"})," (SERializer/DEserializer)."]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["Open ",(0,i.jsx)(t.code,{children:"Cargo.toml"})," and add ",(0,i.jsx)(t.code,{children:"serde"})," to your dependencies:","\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-toml",children:'[dependencies]\nserde = { version = "1.0", features = ["derive"] }\n# ... existing dependencies\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"2-backend-challenge-rust",children:(0,i.jsx)(t.strong,{children:"2. Backend Challenge (Rust)"})}),"\n",(0,i.jsx)(t.p,{children:"You need to query the filesystem for metadata and map it to a struct."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Requirements:"})}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["Define a Rust ",(0,i.jsx)(t.code,{children:"struct"})," representing the file stats."]}),"\n",(0,i.jsxs)(t.li,{children:["Derive ",(0,i.jsx)(t.code,{children:"Serialize"})," so Tauri can convert it to JSON automatically."]}),"\n",(0,i.jsxs)(t.li,{children:["Use ",(0,i.jsx)(t.code,{children:"std::fs::metadata"})," to populate the data."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Starter Code:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:"use std::fs;\nuse serde::Serialize;\n\n// This struct will be converted to a JSON object automatically\n#[derive(Serialize)]\nstruct FileStats {\n    size_bytes: u64,\n    is_readonly: bool,\n    // Challenge: 'modified' returns SystemTime, which is not directly serializable to JSON.\n    // You must figure out how to convert SystemTime to a UNIX timestamp (u64) or String.\n    last_modified: u64,\n}\n\n#[tauri::command]\nfn get_file_stats(path: String) -> Result<FileStats, String> {\n    // TODO:\n    // 1. Call fs::metadata(&path)\n    // 2. Handle the Result (match or ?)\n    // 3. Map the Metadata struct to your FileStats struct\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"3-frontend-challenge-typescript",children:(0,i.jsx)(t.strong,{children:"3. Frontend Challenge (TypeScript)"})}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:'Create a "Properties" view or a footer bar in your editor.'}),"\n",(0,i.jsxs)(t.li,{children:["When a file is active, invoke ",(0,i.jsx)(t.code,{children:"get_file_stats"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:["Display the size.","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.em,{children:"Math Challenge:"})," Convert the raw bytes into human-readable units (KB, MB, GB)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"4-deep-dive-the-time-problem",children:(0,i.jsx)(t.strong,{children:"4. Deep Dive: The Time Problem"})}),"\n",(0,i.jsxs)(t.p,{children:["In C++, ",(0,i.jsx)(t.code,{children:"time_t"})," is usually just an integer. In Rust, ",(0,i.jsx)(t.code,{children:"SystemTime"})," is an opaque type designed to be platform-independent."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"The Hurdle:"})," You cannot send ",(0,i.jsx)(t.code,{children:"SystemTime"})," directly to JS."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"The Hint:"})," Look for ",(0,i.jsx)(t.code,{children:"duration_since(UNIX_EPOCH)"})," in the Rust documentation to convert the time object into a simple number that JavaScript's ",(0,i.jsx)(t.code,{children:"new Date()"})," can parse."]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"conclusion-task-4",children:(0,i.jsx)(t.strong,{children:"Conclusion Task 4"})}),"\n",(0,i.jsx)(t.p,{children:"Completing this task demonstrates mastery of:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"System Abstraction:"})," Using ",(0,i.jsx)(t.code,{children:"std::fs"})," to normalize OS-specific file attributes."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"FFI (Foreign Function Interface):"})," Marshalling complex data structures between Rust and JS via Serde."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:'"You now control not just the content, but the container."'})," \ud83e\udd80\u2728"]}),"\n",(0,i.jsx)(t.hr,{})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>l});var s=n(6540);const i={},r=s.createContext(i);function o(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);