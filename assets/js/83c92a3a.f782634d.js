"use strict";(self.webpackChunkupb_rustworkshop_github_io=self.webpackChunkupb_rustworkshop_github_io||[]).push([[6671],{5483:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"web_server/build-a-system-monitor/task-3","title":"Task 3 - Make metrics realtime","description":"Last time, we added the /metrics and /metrics/ endpoints to our server. Now, a natural feature we could implement is a real-time endpoint that sends metric updates at a fixed rate. This will allow clients to subscribe to the endpoint and receive live updates without polling the server.","source":"@site/docs/web_server/2.build-a-system-monitor/3.task-3.md","sourceDirName":"web_server/2.build-a-system-monitor","slug":"/web_server/build-a-system-monitor/task-3","permalink":"/docs/web_server/build-a-system-monitor/task-3","draft":false,"unlisted":false,"editUrl":"https://github.com/UPB-RustWorkshop/upb-rustworkshop.github.io/edit/main/docs/web_server/2.build-a-system-monitor/3.task-3.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Task 3 - Make metrics realtime"},"sidebar":"tutorialSidebar","previous":{"title":"Task 2 - Implement the `/metrics` endpoints","permalink":"/docs/web_server/build-a-system-monitor/task-2"},"next":{"title":"Links and docs","permalink":"/docs/web_server/docs"}}');var n=s(4848),i=s(8453);const o={title:"Task 3 - Make metrics realtime"},a="Task 3: Add the /realtime endpoint to server realtime metrics.",d={},l=[{value:"What are Server-Sent Events (SSE)?",id:"what-are-server-sent-events-sse",level:2},{value:"Your Task",id:"your-task",level:2},{value:"Hint",id:"hint",level:3}];function c(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsxs)(t.h1,{id:"task-3-add-the-realtime-endpoint-to-server-realtime-metrics",children:["Task 3: Add the ",(0,n.jsx)(t.code,{children:"/realtime"})," endpoint to server realtime metrics."]})}),"\n",(0,n.jsxs)(t.p,{children:["Last time, we added the ",(0,n.jsx)(t.code,{children:"/metrics"})," and ",(0,n.jsx)(t.code,{children:"/metrics/{kind}"})," endpoints to our server. Now, a natural feature we could implement is a real-time endpoint that sends metric updates at a fixed rate. This will allow clients to subscribe to the endpoint and receive live updates without polling the server."]}),"\n",(0,n.jsxs)(t.p,{children:["To do so, we'll implement the ",(0,n.jsx)(t.code,{children:"/realtime"})," endpoint using Server-Sent Events (SSE). This technology allows servers to push updates to clients over a single, long-lived connection."]}),"\n",(0,n.jsx)(t.h2,{id:"what-are-server-sent-events-sse",children:"What are Server-Sent Events (SSE)?"}),"\n",(0,n.jsx)(t.p,{children:"Server-Sent Events (SSE) is a standard for sending real-time updates from a server to a client over HTTP. It's a simple and efficient way to stream data from the server to the client without the need for polling."}),"\n",(0,n.jsx)(t.p,{children:"SSE works by establishing a persistent connection between the client and the server. The server can then send messages to the client at any time, and the client will receive them as they arrive."}),"\n",(0,n.jsxs)(t.p,{children:["In our project, we'll use SSE to stream live metric updates to clients who connect to the ",(0,n.jsx)(t.code,{children:"/realtime"})," endpoint."]}),"\n",(0,n.jsx)(t.h2,{id:"your-task",children:"Your Task"}),"\n",(0,n.jsxs)(t.p,{children:["As task, implement the ",(0,n.jsx)(t.code,{children:"/realtime"})," endpoint to stream live metric updates using Server-Sent Events (SSE). The endpoint should send a message every second with the current system metrics."]}),"\n",(0,n.jsxs)(t.p,{children:["To do so, we'll use the ",(0,n.jsx)(t.code,{children:"tokio-stream"})," crate to create a stream that sends updates at a fixed rate. We'll then use the ",(0,n.jsx)(t.code,{children:"axum::sse"})," module to send these updates to clients."]}),"\n",(0,n.jsx)(t.h3,{id:"hint",children:"Hint"}),"\n",(0,n.jsx)(t.p,{children:"To generate a new metric every second, we'll use the following code:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"use std::time::Duration;\nuse tokio_stream::{StreamExt, wrappers::IntervalStream};\n\nlet stream = IntervalStream::new(tokio::time::interval(Duration::from_secs(1)));\n"})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>a});var r=s(6540);const n={},i=r.createContext(n);function o(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);