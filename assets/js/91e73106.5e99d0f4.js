"use strict";(self.webpackChunkupb_rustworkshop_github_io=self.webpackChunkupb_rustworkshop_github_io||[]).push([[8703],{1470:(e,n,i)=>{i.d(n,{A:()=>w});var s=i(6540),t=i(4164),l=i(7559),r=i(3104),a=i(6347),o=i(205),c=i(7485),d=i(1682),h=i(679);function u(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function x(e){const{values:n,children:i}=e;return(0,s.useMemo)((()=>{const e=n??function(e){return u(e).map((({props:{value:e,label:n,attributes:i,default:s}})=>({value:e,label:n,attributes:i,default:s})))}(i);return function(e){const n=(0,d.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,i])}function p({value:e,tabValues:n}){return n.some((n=>n.value===e))}function m({queryString:e=!1,groupId:n}){const i=(0,a.W6)(),t=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,c.aZ)(t),(0,s.useCallback)((e=>{if(!t)return;const n=new URLSearchParams(i.location.search);n.set(t,e),i.replace({...i.location,search:n.toString()})}),[t,i])]}function f(e){const{defaultValue:n,queryString:i=!1,groupId:t}=e,l=x(e),[r,a]=(0,s.useState)((()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!p({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const i=n.find((e=>e.default))??n[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:n,tabValues:l}))),[c,d]=m({queryString:i,groupId:t}),[u,f]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[i,t]=(0,h.Dv)(n);return[i,(0,s.useCallback)((e=>{n&&t.set(e)}),[n,t])]}({groupId:t}),b=(()=>{const e=c??u;return p({value:e,tabValues:l})?e:null})();(0,o.A)((()=>{b&&a(b)}),[b]);return{selectedValue:r,selectValue:(0,s.useCallback)((e=>{if(!p({value:e,tabValues:l}))throw new Error(`Can't select invalid tab value=${e}`);a(e),d(e),f(e)}),[d,f,l]),tabValues:l}}var b=i(2303);const j={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var g=i(4848);function y({className:e,block:n,selectedValue:i,selectValue:s,tabValues:l}){const a=[],{blockElementScrollPositionUntilNextRender:o}=(0,r.a_)(),c=e=>{const n=e.currentTarget,t=a.indexOf(n),r=l[t].value;r!==i&&(o(n),s(r))},d=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const i=a.indexOf(e.currentTarget)+1;n=a[i]??a[0];break}case"ArrowLeft":{const i=a.indexOf(e.currentTarget)-1;n=a[i]??a[a.length-1];break}}n?.focus()};return(0,g.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,t.A)("tabs",{"tabs--block":n},e),children:l.map((({value:e,label:n,attributes:s})=>(0,g.jsx)("li",{role:"tab",tabIndex:i===e?0:-1,"aria-selected":i===e,ref:e=>{a.push(e)},onKeyDown:d,onClick:c,...s,className:(0,t.A)("tabs__item",j.tabItem,s?.className,{"tabs__item--active":i===e}),children:n??e},e)))})}function v({lazy:e,children:n,selectedValue:i}){const l=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=l.find((e=>e.props.value===i));return e?(0,s.cloneElement)(e,{className:(0,t.A)("margin-top--md",e.props.className)}):null}return(0,g.jsx)("div",{className:"margin-top--md",children:l.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==i})))})}function k(e){const n=f(e);return(0,g.jsxs)("div",{className:(0,t.A)(l.G.tabs.container,"tabs-container",j.tabList),children:[(0,g.jsx)(y,{...n,...e}),(0,g.jsx)(v,{...n,...e})]})}function w(e){const n=(0,b.A)();return(0,g.jsx)(k,{...e,children:u(e.children)},String(n))}},7721:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>x,frontMatter:()=>o,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"linux_kernel_development/index","title":"Linux Kernel Development","description":"Prerequisits","source":"@site/docs/linux_kernel_development/index.mdx","sourceDirName":"linux_kernel_development","slug":"/linux_kernel_development/","permalink":"/docs/linux_kernel_development/","draft":false,"unlisted":false,"editUrl":"https://github.com/UPB-RustWorkshop/upb-rustworkshop.github.io/edit/main/docs/linux_kernel_development/index.mdx","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7,"title":"Linux Kernel Development"},"sidebar":"tutorialSidebar","previous":{"title":"Links and docs","permalink":"/docs/web_server/docs"},"next":{"title":"Empty Module","permalink":"/docs/linux_kernel_development/empty"}}');var t=i(4848),l=i(8453),r=i(1470),a=i(9365);const o={sidebar_position:7,title:"Linux Kernel Development"},c="Linux Kernel Development",d={},h=[{value:"Prerequisits",id:"prerequisits",level:2},{value:"Variables",id:"variables",level:2},{value:"Setup the Kernel",id:"setup-the-kernel",level:2},{value:"Build the kernel with Rust Support",id:"build-the-kernel-with-rust-support",level:3},{value:"Configure the Kernel",id:"configure-the-kernel",level:3},{value:"Build the kernel",id:"build-the-kernel",level:3},{value:"Run the kernel",id:"run-the-kernel",level:3},{value:"Build a Minimal System Filesystem",id:"build-a-minimal-system-filesystem",level:2},{value:"Build RAM disk",id:"build-ram-disk",level:3},{value:"Boot the kernel with the RAM disk",id:"boot-the-kernel-with-the-ram-disk",level:3},{value:"Run a Rust app as <code>init</code>",id:"run-a-rust-app-as-init",level:3},{value:"Setup BusyBox",id:"setup-busybox",level:2},{value:"Build BusyBox",id:"build-busybox",level:3},{value:"Install BusyBox",id:"install-busybox",level:3},{value:"The <code>init</code> script",id:"the-init-script",level:3}];function u(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"linux-kernel-development",children:"Linux Kernel Development"})}),"\n","\n",(0,t.jsx)(n.h2,{id:"prerequisits",children:"Prerequisits"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Linux x86 64bit","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"We recommend Ubuntu LTS or Fedora"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"GCC Compiler"}),"\n",(0,t.jsx)(n.li,{children:"LLVM Compiler"}),"\n",(0,t.jsx)(n.li,{children:"QEMU"}),"\n",(0,t.jsx)(n.li,{children:"Rust 1.90"}),"\n",(0,t.jsxs)(n.li,{children:["Code Editor with ",(0,t.jsx)(n.a,{href:"https://rust-analyzer.github.io/",children:"rust-analyzer"})," support"]}),"\n"]}),"\n",(0,t.jsxs)(r.A,{children:[(0,t.jsx)(a.A,{value:"ubuntu",label:"Ubuntu",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"# Update the package library\n$ sudo apt-get\n\n# Kernel Compilation\n$ sudo apt-get install -y build-essential git libncurses-dev clang flex bison lld libelf-dev\n\n# Install QEMU\n$ sudo apt-get install -y qemu-system\n"})})}),(0,t.jsx)(a.A,{value:"fedora",label:"Fedora",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"# Update the package library\n$ dnf update\n\n# Kernel Compilation\n$ dnf install -y make clang ncurses-devel flex bison lld llvm elfutils-libelf-devel glibc-static\n\n# BusyBox Compilation\n$ dnf install -y glibc-static\n\n# Install QEMU\n$ dnf install -y qemu-system-x86_64\n"})})})]}),"\n",(0,t.jsx)(n.h2,{id:"variables",children:"Variables"}),"\n",(0,t.jsx)(n.p,{children:"We will use these variables througout the workshop."}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Variable"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"$KDIR"})}),(0,t.jsx)(n.td,{children:"The kernel's source directory"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"$MODULE"})}),(0,t.jsxs)(n.td,{children:["The name of the kenrel module's object name (ex: ",(0,t.jsx)(n.code,{children:"empty.ko"}),")"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"$INIT_RAM_FS"})}),(0,t.jsx)(n.td,{children:"Foldetr where we stotre the development file system"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"setup-the-kernel",children:"Setup the Kernel"}),"\n",(0,t.jsxs)(n.p,{children:["Unzip the kernel archive (usually named ",(0,t.jsx)(n.code,{children:"linux-6.18-rc5.tar.gz"}),") and enter in the\nfolder."]}),"\n",(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsxs)(n.p,{children:["We will call the folder in which you have unarchived the kernel ",(0,t.jsx)(n.code,{children:"$KDIR"}),". We suggest setting\nand environment variable with the path to this folder."]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"$ export KDIR=/home/user/linux-6.18-rc5\n"})})]}),"\n",(0,t.jsx)(n.h3,{id:"build-the-kernel-with-rust-support",children:"Build the kernel with Rust Support"}),"\n",(0,t.jsx)(n.p,{children:"Verify if Rust is available and can be used to compile kernel."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ make LLVM=1 rustavailable\n# Rust is available!\n"})}),"\n",(0,t.jsx)(n.p,{children:"Clean the kernel to make sure to delete any previous compilation artefacts."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ make LLVM=1 mrproper\n"})}),"\n",(0,t.jsx)(n.h3,{id:"configure-the-kernel",children:"Configure the Kernel"}),"\n",(0,t.jsx)(n.p,{children:"The Linux kernel is very large, having thousends of components and drivers.\nWe want a minimal configartion that allows use to write Rust drivers."}),"\n",(0,t.jsxs)(n.p,{children:["To start from a minimal configuration, we use the ",(0,t.jsx)(n.code,{children:"allnoconfig"})," setup. This will enable\nonly the minimal components needed to boot."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ make LLVM=1 allnoconfig\n"})}),"\n",(0,t.jsx)(n.p,{children:"We have to add on top of the minimal kernel some components that allows us to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Compile the kernel for Intel x86 64 bits"}),"\n",(0,t.jsx)(n.li,{children:"Use Rust to write drivers"}),"\n",(0,t.jsx)(n.li,{children:"Use a RAM drive as the root of the file system"}),"\n",(0,t.jsx)(n.li,{children:"Use a serial port for the console"}),"\n",(0,t.jsxs)(n.li,{children:["Use the kernel special virtual file systems ",(0,t.jsx)(n.code,{children:"procfs"}),", ",(0,t.jsx)(n.code,{children:"devfs"}),",  and ",(0,t.jsx)(n.code,{children:"sysfs"})]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ make LLVM=1 menuconfig\n"})}),"\n",(0,t.jsx)(n.p,{children:"Make sure the following components are selected:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"- 64bit Kernel (no Rust otherwise)\n- General setup \n  - Initial RAM filesystem and RAM disk\n- General setup\n  - Rust Support\n- Enable loadable module support\n  - Module unloading\n- Executable file formats\n  - Kernel support for ELF binaries\n  - Kernel support for scripts starting with #! (*)\n- Kernel hacking\n  - Rust hacking\n    - Debug assertions\n    - Overflow checks\n    - Allow unoptimized build-time assertions\n- Device Drivers\n  - Generic driver options\n    - Maintain a devtmpfs filesystem to mount at /dev\n      - Automount devtmpfs at /dev, after kernel mounted the rootfs\n  - Character devices\n    - Enable tty\n    - Serial drivers\n      - 8250/16550 and compatible serial support\n      - Console on 8250/16550 and compatible serial port\n- File systems \n  - Pseudo filesystems\n    - /proc file system support\n    - Sysctl support (/proc/sys)\n    - sysfs file system support\n    - Userspace-driven configuration filesystem\n"})}),"\n",(0,t.jsx)(n.h3,{id:"build-the-kernel",children:"Build the kernel"}),"\n",(0,t.jsx)(n.p,{children:"Now let's build the kernel."}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsx)(n.p,{children:"As this wil take a longer time, we want to make sure we use all the avilable cores."}),(0,t.jsxs)(n.p,{children:["Replace the ",(0,t.jsx)(n.code,{children:"n"})," in ",(0,t.jsx)(n.code,{children:"-jn"})," with the number of cores that your laptop has."]})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ make LLVM=1 -jn # replace n with the number of cores your laptop has\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The kernel is built in ",(0,t.jsx)(n.code,{children:"arch/x86/boot/bzImage"})]}),"\n",(0,t.jsx)(n.h3,{id:"run-the-kernel",children:"Run the kernel"}),"\n",(0,t.jsxs)(n.p,{children:["We will use QEMU to run a machine and boot our kernel. Instead of using a bootloader, QEMU\nprovides a minimal bootloader that can load a ",(0,t.jsx)(n.code,{children:"multiboot v1"})," compatible kernel that is\nsupplied using the ",(0,t.jsx)(n.code,{children:"-kernel"})," argument. The Linux kernel is compatible."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'$ qemu-system-x86_64 -kernel arch/x86_64/boot/bzImage -nographic -append "earlyprintk=serial,ttyS0 console=ttyS0 debug"\n'})}),"\n",(0,t.jsx)(n.p,{children:"Running QEMU should print an output similar to:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:'Linux version 6.18.0-rc4 (alexandru@fedora) (clang version 21.1.3 (Fedora 21.1.3-1.fc43), LLD 21.1.3) #6 Thu Nov 13 11:21:16 EET 2025\nCommand line: earlyprintk=serial,ttyS0 console=ttyS0 debug\nBIOS-provided physical RAM map:\nBIOS-e820: [mem 0x0000000000000000-0x000000000009fbff] usable\nBIOS-e820: [mem 0x000000000009fc00-0x000000000009ffff] reserved\nBIOS-e820: [mem 0x00000000000f0000-0x00000000000fffff] reserved\nBIOS-e820: [mem 0x0000000000100000-0x0000000007fdffff] usable\nBIOS-e820: [mem 0x0000000007fe0000-0x0000000007ffffff] reserved\nBIOS-e820: [mem 0x00000000fffc0000-0x00000000ffffffff] reserved\nBIOS-e820: [mem 0x000000fd00000000-0x000000ffffffffff] reserved\nprintk: legacy bootconsole [earlyser0] enabled\nNX (Execute Disable) protection: active\nAPIC: Static calls initialized\nSMBIOS 2.8 present.\nDMI: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.17.0-6.fc43 04/01/2014\nDMI: Memory slots populated: 1/1\ntsc: Fast TSC calibration using PIT\ntsc: Detected 3293.791 MHz processor\ne820: update [mem 0x00000000-0x00000fff] usable ==> reserved\ne820: remove [mem 0x000a0000-0x000fffff] usable\nlast_pfn = 0x7fe0 max_arch_pfn = 0x400000000\nMTRR map: 4 entries (3 fixed + 1 variable; max 19), built from 8 variable MTRRs\nx86/PAT: Configuration [0-7]: WB  WC  UC- UC  WB  WP  UC- WT  \nfound SMP MP-table at [mem 0x000f5460-0x000f546f]\nIntel MultiProcessor Specification v1.4\nMPTABLE: OEM ID: BOCHSCPU\nMPTABLE: Product ID: 0.1         \nMPTABLE: APIC at: 0xFEE00000\nZone ranges:\n  DMA      [mem 0x0000000000001000-0x0000000000ffffff]\n  DMA32    [mem 0x0000000001000000-0x0000000007fdffff]\n  Normal   empty\nMovable zone start for each node\nEarly memory node ranges\n  node   0: [mem 0x0000000000001000-0x000000000009efff]\n  node   0: [mem 0x0000000000100000-0x0000000007fdffff]\nInitmem setup node 0 [mem 0x0000000000001000-0x0000000007fdffff]\nOn node 0, zone DMA: 1 pages in unavailable ranges\nOn node 0, zone DMA: 97 pages in unavailable ranges\nOn node 0, zone DMA32: 32 pages in unavailable ranges\nIntel MultiProcessor Specification v1.4\nMPTABLE: OEM ID: BOCHSCPU\nMPTABLE: Product ID: 0.1         \nMPTABLE: APIC at: 0xFEE00000\nProcessor #0 (Bootup-CPU)\nIOAPIC[0]: apic_id 0, version 32, address 0xfec00000, GSI 0-23\nProcessors: 1\nCPU topo: Max. logical packages:   1\nCPU topo: Max. logical dies:       1\nCPU topo: Max. dies per package:   1\nCPU topo: Max. threads per core:   1\nCPU topo: Num. cores per package:     1\nCPU topo: Num. threads per package:   1\nCPU topo: Allowing 1 present CPUs plus 0 hotplug CPUs\n[mem 0x08000000-0xfffbffff] available for PCI devices\nclocksource: refined-jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 7645519600211568 ns\npcpu-alloc: s0 r0 d32768 u32768 alloc=1*32768\npcpu-alloc: [0] 0 \nKernel command line: earlyprintk=serial,ttyS0 console=ttyS0 debug\nprintk: log buffer data + meta data: 131072 + 458752 = 589824 bytes\nDentry cache hash table entries: 16384 (order: 5, 131072 bytes, linear)\nInode-cache hash table entries: 8192 (order: 4, 65536 bytes, linear)\nBuilt 1 zonelists, mobility grouping on.  Total pages: 32638\nmem auto-init: stack:all(zero), heap alloc:off, heap free:off\nSLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1\nNR_IRQS: 4352, nr_irqs: 48, preallocated irqs: 16\nConsole: colour VGA+ 80x25\nprintk: legacy console [ttyS0] enabled\nprintk: legacy console [ttyS0] enabled\nprintk: legacy bootconsole [earlyser0] disabled\nprintk: legacy bootconsole [earlyser0] disabled\nAPIC: Switch to symmetric I/O mode setup\n..TIMER: vector=0x30 apic1=0 pin1=2 apic2=-1 pin2=-1\nclocksource: tsc-early: mask: 0xffffffffffffffff max_cycles: 0x2f7a62d5034, max_idle_ns: 440795340533 ns\nCalibrating delay loop (skipped), value calculated using timer frequency.. 6587.58 BogoMIPS (lpj=13175164)\nLast level iTLB entries: 4KB 512, 2MB 255, 4MB 127\nLast level dTLB entries: 4KB 512, 2MB 255, 4MB 127, 1GB 0\nCPU: AMD QEMU Virtual CPU version 2.5+ (family: 0xf, model: 0x6b, stepping: 0x1)\nmitigations: Enabled attack vectors: SMT mitigations: off\nSpectre V2 : Vulnerable\nSpectre V1 : Vulnerable: __user pointer sanitization and usercopy barriers only; no swapgs barriers\nx86/fpu: x87 FPU will use FXSAVE\npid_max: default: 32768 minimum: 301\nMount-cache hash table entries: 512 (order: 0, 4096 bytes, linear)\nMountpoint-cache hash table entries: 512 (order: 0, 4096 bytes, linear)\nPerformance Events: PMU not available due to virtualization, using software events only.\nsignal: max sigframe size: 1040\nMemory: 116260K/130552K available (4954K kernel code, 765K rwdata, 1172K rodata, 668K init, 568K bss, 13228K reserved, 0K cma-reserved)\ndevtmpfs: initialized\nclocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 7645041785100000 ns\nposixtimers hash table entries: 512 (order: 0, 4096 bytes, linear)\nfutex hash table entries: 256 (8192 bytes on 1 NUMA nodes, total 8 KiB, linear).\nclocksource: Switched to clocksource tsc-early\nplatform rtc_cmos: registered platform RTC device (no PNP device found)\nworkingset: timestamp_bits=62 max_order=15 bucket_order=0\nSerial: 8250/16550 driver, 4 ports, IRQ sharing disabled\nserial8250: ttyS0 at I/O 0x3f8 (irq = 4, base_baud = 115200) is a 16550A\nsched_clock: Marking stable (376496896, 7725973)->(388498526, -4275657)\ncheck access for rdinit=/init failed: -2, ignoring\nList of all partitions:\nNo filesystem could mount root, tried: \n\nKernel panic - not syncing: VFS: Unable to mount root fs on "" or unknown-block(0,0)\nCPU: 0 UID: 0 PID: 1 Comm: swapper/0 Not tainted 6.18.0-rc4 #6 NONE \nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.17.0-6.fc43 04/01/2014\nCall Trace:\n <TASK>\n __dump_stack+0x19/0x20\n dump_stack_lvl+0x20/0x50\n dump_stack+0x14/0x16\n vpanic+0xc9/0x260\n panic+0x4a/0x50\n mount_root_generic+0x184/0x280\n ? rest_init+0x90/0x90\n mount_block_root+0x3a/0x40\n mount_root+0x5f/0x70\n prepare_namespace+0x70/0xa0\n kernel_init_freeable+0xb0/0xd0\n kernel_init+0x19/0x110\n ret_from_fork+0x84/0xd0\n ? rest_init+0x90/0x90\n ret_from_fork_asm+0x11/0x20\n </TASK>\nKernel Offset: disabled\n---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on "" or unknown-block(0,0) ]---\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"The kernel panicked!"})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["Press ",(0,t.jsx)(n.code,{children:"CTRL"}),"+",(0,t.jsx)(n.code,{children:"a"})," folloed by ",(0,t.jsx)(n.code,{children:"x"})," to exit QEMU."]})}),"\n",(0,t.jsx)(n.p,{children:"This is normal, let's take a look at why it panicked."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'List of all partitions:\nNo filesystem could mount root, tried: \n\nKernel panic - not syncing: VFS: Unable to mount root fs on "" or unknown-block(0,0)\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The reason for panic is that it was ",(0,t.jsx)(n.strong,{children:"not able to mount the root file"})," system. This is\ncorrect, we did not suply any disk drive that has a file system to use. The kernel\ncannot run without a root file system."]}),"\n",(0,t.jsx)(n.h2,{id:"build-a-minimal-system-filesystem",children:"Build a Minimal System Filesystem"}),"\n",(0,t.jsxs)(n.p,{children:["Now that we have a kernel, we need to build a minimal file system and provide an ",(0,t.jsx)(n.code,{children:"init"})," process.\nWe will use the kernel's ",(0,t.jsx)(n.code,{children:"initramfs"})," file system. This is an in-RAM file system that the kernel\nreceives from the bootloader (QEMU in our case), mounts in RAM and uses as the root file system."]}),"\n",(0,t.jsx)(n.h3,{id:"build-ram-disk",children:"Build RAM disk"}),"\n",(0,t.jsxs)(n.p,{children:["We have to create the directory for the ",(0,t.jsx)(n.code,{children:"initramfs"}),". We will refer to this directory as ",(0,t.jsx)(n.code,{children:"$INIT_RAM_FS"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ mkdir initramfs\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The kernel expects a compressed ",(0,t.jsx)(n.code,{children:"cpio"})," file system type. To create an archive with the contents of\n",(0,t.jsx)(n.code,{children:"$INIT_RAM_FS"})," we use ",(0,t.jsx)(n.code,{children:"find"}),", ",(0,t.jsx)(n.code,{children:"cpio"})," and ",(0,t.jsx)(n.code,{children:"gz"})," in the ",(0,t.jsx)(n.code,{children:"$INIT_RAM_FS"})," folder."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ find . -print0 | cpio --null -ov --format=newc | gzip -9 > ../initramfs.cpio.gz\n"})}),"\n",(0,t.jsx)(n.h3,{id:"boot-the-kernel-with-the-ram-disk",children:"Boot the kernel with the RAM disk"}),"\n",(0,t.jsxs)(n.p,{children:["We have to add the ",(0,t.jsx)(n.code,{children:"--initrd"})," argument to QEMU."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'$ qemu-system-x86_64 -kernel arch/x86_64/boot/bzImage -nographic -append "earlyprintk=serial,ttyS0 console=ttyS0 debug" --initrd initramfs.cpio.gz\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"The kernel boots, but it seems to show use the same panic!"})}),"\n",(0,t.jsx)(n.p,{children:"This is strange, as we have supplied a root file system. The hint is the following line:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"check access for rdinit=/init failed: -2, ignoring\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The kernel requires an ",(0,t.jsx)(n.code,{children:"init"})," process to run. As it cannot find one, it will consider the RAM file system as being\ninvalid and panics."]}),"\n",(0,t.jsxs)(n.h3,{id:"run-a-rust-app-as-init",children:["Run a Rust app as ",(0,t.jsx)(n.code,{children:"init"})]}),"\n",(0,t.jsxs)(n.p,{children:["The RAM file system is completely empty, we have no shell or no libraries. The simplest ",(0,t.jsx)(n.code,{children:"init"})," application\nis a compiled program that prints ",(0,t.jsx)(n.em,{children:"Hello, world!"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["As this is a Rust workshop, let's write a Rust program that acts as ",(0,t.jsx)(n.code,{children:"init"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["To create a new rust program (binary crate) we run ",(0,t.jsx)(n.code,{children:"cargo init"}),". This will crate a folder with all the\nrequired files."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:".\n\u251c\u2500\u2500 Cargo.toml\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 main.rs\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The simplest init program is one that write ",(0,t.jsx)(n.em,{children:"Hello, world!"}),". It is so simple that ",(0,t.jsx)(n.code,{children:"cargo"})," has\nalready written it for us."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    println!("Hello, world!");\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["We use ",(0,t.jsx)(n.code,{children:"cargo build"})," to build it."]}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["To optimize the binary size, you can use ",(0,t.jsx)(n.code,{children:"cargo build --release"}),"."]})}),"\n",(0,t.jsxs)(n.p,{children:["We will find the executable in ",(0,t.jsx)(n.code,{children:"target/debug/init"})," or ",(0,t.jsx)(n.code,{children:"target/release/init"}),". We have to copy this file\nin the ",(0,t.jsx)(n.code,{children:"$INIT_RAM_FS"})," folder and ",(0,t.jsx)(n.a,{href:"#build-ram-disk",children:"rebuild the RAM disk"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Running the kernel with the new contants of the RAM disk still panics, but with a different panic message:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"Run /init as init process\n  with arguments:\n    /init\n  with environment:\n    HOME=/\n    TERM=linux\nFailed to execute /init (error -2)\nRun /sbin/init as init process\n  with arguments:\n    /sbin/init\n  with environment:\n    HOME=/\n    TERM=linux\nRun /etc/init as init process\n  with arguments:\n    /etc/init\n  with environment:\n    HOME=/\n    TERM=linux\nRun /bin/init as init process\n  with arguments:\n    /bin/init\n  with environment:\n    HOME=/\n    TERM=linux\nRun /bin/sh as init process\n  with arguments:\n    /bin/sh\n  with environment:\n    HOME=/\n    TERM=linux\nKernel panic - not syncing: No working init found.  Try passing init= option to kernel. See Linux Documentation/admin-guide/init.rst for guidance.\n"})}),"\n",(0,t.jsxs)(n.p,{children:["As we can see, the kernel found the ",(0,t.jsx)(n.code,{children:"init"})," executable, tried to run and failed with ",(0,t.jsx)(n.code,{children:"Failed to execute /init (error -2)"}),". We compiled the\n",(0,t.jsx)(n.code,{children:"init"})," executable for Linux, which means it requires Linux libraries. Running ",(0,t.jsx)(n.code,{children:"ldd"})," on the ",(0,t.jsx)(n.code,{children:"init"})," executable will write:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ ldd target/debug/init\n    linux-vdso.so.1 (0x00007f45a855e000)\n    libgcc_s.so.1 => /lib64/libgcc_s.so.1 (0x00007f45a84ba000)\n    libc.so.6 => /lib64/libc.so.6 (0x00007f45a82c6000)\n    /lib64/ld-linux-x86-64.so.2 (0x00007f45a8560000)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This means that our ",(0,t.jsx)(n.code,{children:"init"})," depends on these libraries. As we have an empty file system, the executable cannot be loaded. We have\nto build ",(0,t.jsx)(n.code,{children:"init"})," as a ",(0,t.jsx)(n.strong,{children:"static executable"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Rust provides the ",(0,t.jsx)(n.code,{children:"x86_64-unknown-linux-musl"}),"  target for building static x86 64 bit Linux executables. We have to ask ",(0,t.jsx)(n.code,{children:"cargo"})," to\nuse this target."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"$ cargo build --target x86_64-unknown-linux-musl\n"})}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsxs)(n.p,{children:["If the build fails, you might have to install the ",(0,t.jsx)(n.code,{children:"x86_64-unknown-linux-musl"})," target using:"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"$ rustup target add x86_64-unknown-linux-musl\n"})})]}),"\n",(0,t.jsxs)(n.p,{children:["The static binary will be placved in ",(0,t.jsx)(n.code,{children:"target/x86_64-unknown-linux-musl/debug/init"}),". Running ",(0,t.jsx)(n.code,{children:"ldd"})," in this file will print ",(0,t.jsx)(n.code,{children:"statically linked"}),"\nand this is what we axctually want. We can now copy our ",(0,t.jsx)(n.code,{children:"init"})," executable to ",(0,t.jsx)(n.code,{children:"$INIT_RAM_FS"})," and ",(0,t.jsx)(n.a,{href:"#build-ram-disk",children:"rebuild it"}),"."]}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsxs)(n.p,{children:["To avoid using the ",(0,t.jsx)(n.code,{children:"--target"})," argument with cargo at every build, we can specify the target a ",(0,t.jsx)(n.code,{children:".cargo/config.toml"})," file."]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-toml",children:'[build]\ntarget = "x86_64-unknown-linux-musl"\n'})}),(0,t.jsxs)(n.p,{children:["You instruct cargo to install all the target and components that you need before the build using the ",(0,t.jsx)(n.code,{children:"rust-toolchain.toml"})," file."]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-toml",children:"# toolchain\n"})})]}),"\n",(0,t.jsx)(n.p,{children:"Rumnning the kernel still panics \ud83e\udd28, but with a different error:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"Run /init as init process\n  with arguments:\n    /init\n  with environment:\n    HOME=/\n    TERM=linux\nHello, world!\nKernel panic - not syncing: Attempted to kill init! exitcode=0x00000000\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"init"})," process has run, we can see the ",(0,t.jsx)(n.code,{children:"Hello, world!"})," messsage, but it exited. ",(0,t.jsx)(n.code,{children:"init"})," is not allowed to\nexit and the kernel will panic if it does. To prevent this, we just add an infinite loop."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use std::{thread, time::Duration};\n\nfn main() {\n    println!("Hello, world!");\n\n    loop {\n        thread::sleep(Duration::from_secs(1));\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"If we build it and run the kernel, we can see it finally works ... sort of, it does nothing."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"Run /init as init process\n  with arguments:\n    /init\n  with environment:\n    HOME=/\n    TERM=linux\nHello, world!\n"})}),"\n",(0,t.jsx)(n.h2,{id:"setup-busybox",children:"Setup BusyBox"}),"\n",(0,t.jsxs)(n.p,{children:["We have created our own ",(0,t.jsx)(n.code,{children:"init"}),", but the syuste is useless when using it. We need to be able to\nrun a shell and execute shell commands. A tool that provides and ",(0,t.jsx)(n.code,{children:"init"})," and the shell commands\nis ",(0,t.jsx)(n.a,{href:"https://busybox.net/",children:"BusyBox"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"We need to statically compile it and install it in the RAM disk."}),"\n",(0,t.jsxs)(n.p,{children:["Download and unarchive ",(0,t.jsx)("a",{href:"/busybox/busybox-1.37.0.tar.bz2",children:"busybox version 1.37"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"build-busybox",children:"Build BusyBox"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ make clean\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ make menuconfig\n"})}),"\n",(0,t.jsxs)(n.admonition,{type:"warning",children:[(0,t.jsxs)(n.p,{children:["BusyBox's build script has a bug when it checks for ",(0,t.jsx)(n.code,{children:"ncurses-devel"}),". Instead of checking if ",(0,t.jsx)(n.code,{children:"lx-dialog"})," exists, it check for\na compilation error. If you get this error, you have to patch the ",(0,t.jsx)(n.code,{children:"scripts/kconfig/lxdialog/check-lxdialog.sh"})," file\nto make sure it writes ",(0,t.jsx)(n.code,{children:"int main"})," in the ",(0,t.jsx)(n.code,{children:"check"})," function."]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:'# Check if we can link to ncurses \ncheck() {\n        $cc -x c - -o $tmp 2>/dev/null <<\'EOF\'\n#include CURSES_LOC\nint main() {}\nEOF\n\tif [ $? != 0 ]; then\n\t    echo " *** Unable to find the ncurses libraries or the"       1>&2\n\t    echo " *** required header files."                            1>&2\n\t    echo " *** \'make menuconfig\' requires the ncurses libraries." 1>&2\n\t    echo " *** "                                                  1>&2\n\t    echo " *** Install ncurses (ncurses-devel) and try again."    1>&2\n\t    echo " *** "                                                  1>&2\n\t    exit 1\n\tfi\n}\n\n'})})]}),"\n",(0,t.jsx)(n.p,{children:"We have to build busy box as a static binary so it can run on our minimal system without\nthe need of any shared libraries."}),"\n",(0,t.jsxs)(n.p,{children:["BusyBox has a bug and newer compiler will fail to compile the ",(0,t.jsx)(n.code,{children:"tc"})," command, so we need to disable it.\n:::"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"- Settings\n  - Build static binary (no shared libs)\n- Networking utilities\n  - tc (8.3 kb) (DISABLE THIS)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["We can now build busybox using ",(0,t.jsx)(n.code,{children:"make"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ make -jn # replace n with the number of cores that your laptop has\n"})}),"\n",(0,t.jsx)(n.h3,{id:"install-busybox",children:"Install BusyBox"}),"\n",(0,t.jsxs)(n.p,{children:["Installing busybox means creating the required folders and copying the ",(0,t.jsx)(n.code,{children:"busybox"})," executable and\nthe links to it to ",(0,t.jsx)(n.code,{children:"$INIT_RAM_FS"}),". The ",(0,t.jsx)(n.code,{children:"install"})," target will copy ",(0,t.jsx)(n.code,{children:"busybox"})," and create\nthe required folders structure in the ",(0,t.jsx)(n.code,{children:"_install"})," folder."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"$ make install\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This is how the ",(0,t.jsx)(n.code,{children:"_install"})," folder should look like:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",metastring:"{limit: 10}",children:"_install\n\u251c\u2500\u2500 bin\n...\n\u2502\xa0\xa0 \u251c\u2500\u2500 busybox\n\u2502\xa0\xa0 \u251c\u2500\u2500 cat -> busybox\n\u2502\xa0\xa0 \u251c\u2500\u2500 chattr -> busybox\n\u2502\xa0\xa0 \u251c\u2500\u2500 chgrp -> busybox\n\u2502\xa0\xa0 \u251c\u2500\u2500 chmod -> busybox\n\u2502\xa0\xa0 \u251c\u2500\u2500 chown -> busybox\n\u2502\xa0\xa0 \u251c\u2500\u2500 conspy -> busybox\n\u2502\xa0\xa0 \u251c\u2500\u2500 cp -> busybox\n...\n\u2502\xa0\xa0 \u251c\u2500\u2500 ls -> busybox\n...\n\u251c\u2500\u2500 linuxrc -> bin/busybox\n\u251c\u2500\u2500 sbin\n...\n\u2502\xa0\xa0 \u251c\u2500\u2500 fdisk -> ../bin/busybox\n...\n\u2514\u2500\u2500 usr\n    \u251c\u2500\u2500 bin\n    \u2502\xa0\xa0 \u251c\u2500\u2500 [ -> ../../bin/busybox\n    \u2502\xa0\xa0 \u251c\u2500\u2500 [[ -> ../../bin/busybox\n    \u2502\xa0\xa0 \u251c\u2500\u2500 ascii -> ../../bin/busybox\n    ...\n    \u2514\u2500\u2500 sbin\n        \u251c\u2500\u2500 addgroup -> ../../bin/busybox\n        \u251c\u2500\u2500 add-shell -> ../../bin/busybox\n        \u251c\u2500\u2500 adduser -> ../../bin/busybox\n        ...\n\n6 directories, 403 files\n"})}),"\n",(0,t.jsx)(n.p,{children:"To use BusyBox, we need to create all the requitred folders in the RAM disk."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ mkdir -p bin sbin etc proc dev sys usr/bin usr/sbin\n"})}),"\n",(0,t.jsxs)(n.p,{children:["We only really need to copy the ",(0,t.jsx)(n.code,{children:"_install/bin/busybox"})," executable to ",(0,t.jsx)(n.code,{children:"$INIT_RAM_FS"}),"."]}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsx)(n.p,{children:"We will instruct BusyBox to install all the links at boot time. If you want to avoid installing\nthem at boot, you can copy all the links using"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"$ cp -r _install/ $INIT_RAM_FS/\n"})})]}),"\n",(0,t.jsxs)(n.h3,{id:"the-init-script",children:["The ",(0,t.jsx)(n.code,{children:"init"})," script"]}),"\n",(0,t.jsxs)(n.p,{children:["BusyBox provides a shell interpreter which means we can now use write and ",(0,t.jsx)(n.code,{children:"init"})," shell script.\nReplace the ",(0,t.jsx)(n.code,{children:"init"})," rust binary with the following shell script."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"#!/bin/busybox sh\n\n# Install the busybox commands and set the PATH variable\n/bin/busybox --install -s\n\n# Mount kernel filesystems\nmount -t proc none /proc\nmount -t sysfs none /sys\nmount -t devtmpfs devtmpfs /dev\n\n# Write a benner\necho << !\n\nWelcome to the Rust Kernel Development Minimal Linux!\nPress CTRL+a x to exit QEMU\n\n!\n\n# Run a shell\nexec /bin/sh\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["Please make sure you name the script ",(0,t.jsx)(n.code,{children:"init"})," (with no ",(0,t.jsx)(n.code,{children:".sh"}),") and make it executable (",(0,t.jsx)(n.code,{children:"chmod a+x init"}),")."]})}),"\n",(0,t.jsx)(n.p,{children:"The file system layout that we will use should look like the following:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"initramfs\n\u251c\u2500\u2500 bin\n\u2502\xa0\xa0 \u2514\u2500\u2500 busybox\n\u251c\u2500\u2500 dev\n\u251c\u2500\u2500 etc\n\u251c\u2500\u2500 init\n\u251c\u2500\u2500 proc\n\u251c\u2500\u2500 sbin\n\u251c\u2500\u2500 sys\n\u2514\u2500\u2500 usr\n    \u251c\u2500\u2500 bin\n    \u2514\u2500\u2500 sbin\n"})}),"\n",(0,t.jsxs)(n.p,{children:["We have to ",(0,t.jsx)(n.a,{href:"#build-ram-disk",children:"rebuild the RAM disk"})," and boot the kernel with the new RAM disk. We should have access to a\nfull shell now."]})]})}function x(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var s=i(6540);const t={},l=s.createContext(t);function r(e){const n=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(l.Provider,{value:n},e.children)}},9365:(e,n,i)=>{i.d(n,{A:()=>r});i(6540);var s=i(4164);const t={tabItem:"tabItem_Ymn6"};var l=i(4848);function r({children:e,hidden:n,className:i}){return(0,l.jsx)("div",{role:"tabpanel",className:(0,s.A)(t.tabItem,i),hidden:n,children:e})}}}]);