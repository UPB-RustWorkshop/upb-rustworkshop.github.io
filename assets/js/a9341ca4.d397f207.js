"use strict";(self.webpackChunkupb_rustworkshop_github_io=self.webpackChunkupb_rustworkshop_github_io||[]).push([[3839],{423:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>c,frontMatter:()=>o,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"linux_kernel_development/reset","title":"Power Off Driver","description":"We will try to build a driver that powers off QEMU.","source":"@site/docs/linux_kernel_development/3.reset.md","sourceDirName":"linux_kernel_development","slug":"/linux_kernel_development/reset","permalink":"/docs/linux_kernel_development/reset","draft":false,"unlisted":false,"editUrl":"https://github.com/UPB-RustWorkshop/upb-rustworkshop.github.io/edit/main/docs/linux_kernel_development/3.reset.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Debug","permalink":"/docs/linux_kernel_development/debug"},"next":{"title":"Misc Driver","permalink":"/docs/linux_kernel_development/misc"}}');var i=r(4848),s=r(8453);const o={},l="Power Off Driver",d={},a=[{value:"ISA Debug Exit",id:"isa-debug-exit",level:2},{value:"Simple Power Off Driver",id:"simple-power-off-driver",level:2},{value:"Reserving the port region",id:"reserving-the-port-region",level:3},{value:"Writing to the port",id:"writing-to-the-port",level:3},{value:"Kernel AT&amp;T Syntax",id:"kernel-att-syntax",level:4},{value:"Intel Sytnax",id:"intel-sytnax",level:4},{value:"Realeasing the port reagion",id:"realeasing-the-port-reagion",level:3},{value:"Exercises",id:"exercises",level:2},{value:"Bonus",id:"bonus",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"power-off-driver",children:"Power Off Driver"})}),"\n",(0,i.jsx)(n.p,{children:"We will try to build a driver that powers off QEMU."}),"\n",(0,i.jsx)(n.h2,{id:"isa-debug-exit",children:"ISA Debug Exit"}),"\n",(0,i.jsx)(n.p,{children:"QEMU provides a virual peripheral called ISA Debug Exit that maps an IO port. Writing a numeric value to this port\nwill power off QEMU and return the value as an error code."}),"\n",(0,i.jsxs)(n.p,{children:["Attaching this device to QEMU is done by adding ",(0,i.jsx)(n.code,{children:"-device isa-debug-exit,iobase=0x10f4,iosize=0x04"})," to the command line.\nIn this example, the debug device is mapped on port ",(0,i.jsx)(n.code,{children:"0x10f4"})," and is 4 bytes long."]}),"\n",(0,i.jsx)(n.h2,{id:"simple-power-off-driver",children:"Simple Power Off Driver"}),"\n",(0,i.jsx)(n.p,{children:"The simplest driver that we can write is one that power off QEMU when it is loaded.\nWe need to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"reserve the port"}),"\n",(0,i.jsx)(n.li,{children:"write to it using x86 assembly"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"reserving-the-port-region",children:"Reserving the port region"}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"The Kernel Rust API does not have (yet) and safe abstraction to reserve a port. This means that\nwe have to use the C binding directly,"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"unsafe { bindings::request_region(start, len, name.as_char_ptr()) }\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"start"})," is the port number"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"len"})," is the gthe length of the port"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"name"})," is a name that will be displayed in ",(0,i.jsx)(n.code,{children:"/proc/ioports"})," and is a C string ",(0,i.jsx)(n.code,{children:"char*"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The function return ",(0,i.jsx)(n.code,{children:"NULL"})," if the port mapping fails. In Rust, we can use the ",(0,i.jsx)(n.code,{children:".is_null()"})," function\nto check if the port reservation worked."]}),"\n",(0,i.jsx)(n.h3,{id:"writing-to-the-port",children:"Writing to the port"}),"\n",(0,i.jsx)(n.p,{children:"Writing to the IO port is done using inline assembly. There are two possible syntaxes:"}),"\n",(0,i.jsx)(n.h4,{id:"kernel-att-syntax",children:"Kernel AT&T Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// kernel API\nuse kernel::asm;\nunsafe {\n    asm!("\n            outb %al, %dx\n        ";\n        in("dx") port as u16, \n        in("al") value as u8\n    );\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"intel-sytnax",children:"Intel Sytnax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// core API\nuse core::arch::asm;\nunsafe {\n    asm!("\n            out dx, al \n        ",\n        in("dx") port as u16, \n        in("al") value as u8\n    );\n}\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["The kernel does not forbid writing to a port without reserving it, but this is bad practice,\nas we might override another driver's ports. if we cannot reserve a port, we just back off\nand fail to load the driver returning a ",(0,i.jsx)(n.code,{children:"EBUSY"})," error."]})}),"\n",(0,i.jsx)(n.h3,{id:"realeasing-the-port-reagion",children:"Realeasing the port reagion"}),"\n",(0,i.jsx)(n.p,{children:"If we have reserved a port region, we must make sure to release it when we do not need it anymore\nor when we unload the driver."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"unsafe { bindings::release_region(start, len); }\n"})}),"\n",(0,i.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Write an empty module called ",(0,i.jsx)(n.code,{children:"Reset"})]}),"\n",(0,i.jsxs)(n.li,{children:["Reserve the ",(0,i.jsx)(n.code,{children:"0x10f4"})," port with 4 bytes long in the ",(0,i.jsx)(n.code,{children:"Module::init"})," function."]}),"\n"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Print the contents of ",(0,i.jsx)(n.code,{children:"/proc/ioports"})," to see if your port has been reserved"]}),"\n",(0,i.jsx)(n.li,{children:"Try reserving a port that already exists and fail to initialize the module"}),"\n"]}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsxs)(n.li,{children:["Release the ",(0,i.jsx)(n.code,{children:"0x10f4"})," port with 4 bytes long in the ",(0,i.jsx)(n.code,{children:"Drop::drop"})," function."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"bonus",children:"Bonus"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Automate the release of the IOPort by using a structure called ",(0,i.jsx)(n.code,{children:"IoPortRegion"})," that reserves the port\nin its ",(0,i.jsx)(n.code,{children:"new"}),". Implement the ",(0,i.jsx)(n.code,{children:"Drop"})," trait for ",(0,i.jsx)(n.code,{children:"IoPortRegion"})," and release the IOPort. Store the\nstructure in the ",(0,i.jsx)(n.code,{children:"Reset"})," driver structure so that it gets dropped when the driver is unloaded."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Use a ",(0,i.jsx)(n.code,{children:"Task"})," to schedule a reset after a certain amount of time defined in a module parameter. Use\na ",(0,i.jsx)(n.a,{href:"https://rust.docs.kernel.org/next/kernel/workqueue/index.html",children:"workqueue"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'/// Stores all the possible tasks (Work)\n#[pin_data]\nstruct DeferredWork {\n    module: &\'static ThisModule,\n    #[pin]\n    work: Work<DeferredWork>,\n}\n\n/// Initializes the possible tasks\nimpl DeferredWork {\n    fn new(module: &\'static ThisModule) -> Result<Arc<DeferredWork>> {\n        Arc::pin_init(\n            pin_init!(DeferredWork {\n                module,\n                work <- new_work!("DeferredWork::work"),\n            }),\n            GFP_KERNEL,\n        )\n    }\n}\n\n/// Must be implemented\nimpl_has_work! {\n    impl HasWork<Self> for DeferredWork { self.work }\n}\n\n/// Implement the task\nimpl WorkItem for DeferredWork {\n    type Pointer = Arc<DeferredWork>;\n\n    fn run(_this: Self::Pointer) {\n        // ...\n    }\n}\n\n/// Setup the work\nfn setup_work() {\n    match DeferredWork::new(module) {\n        Ok(work) => {\n            let _ = workqueue::system().enqueue(work);\n        }\n        Err(err) => {\n            pr_warn!("Failed to setup work: {:?}", err);\n        }\n    }\n}\n'})})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>l});var t=r(6540);const i={},s=t.createContext(i);function o(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);