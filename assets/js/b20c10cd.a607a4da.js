"use strict";(self.webpackChunkupb_rustworkshop_github_io=self.webpackChunkupb_rustworkshop_github_io||[]).push([[398],{2725:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>a,frontMatter:()=>t,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"linux_kernel_development/empty","title":"Empty Module","description":"The first exercise is to write an empty  module. The module will print a message when it loads and","source":"@site/docs/linux_kernel_development/1.empty.md","sourceDirName":"linux_kernel_development","slug":"/linux_kernel_development/empty","permalink":"/docs/linux_kernel_development/empty","draft":false,"unlisted":false,"editUrl":"https://github.com/UPB-RustWorkshop/upb-rustworkshop.github.io/edit/main/docs/linux_kernel_development/1.empty.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Linux Kernel Development","permalink":"/docs/linux_kernel_development/"},"next":{"title":"Debug","permalink":"/docs/linux_kernel_development/debug"}}');var s=l(4848),i=l(8453);const t={},d="Empty Module",o={},c=[{value:"Tree Structure",id:"tree-structure",level:2},{value:"Kbuild File",id:"kbuild-file",level:3},{value:"Makefile",id:"makefile",level:3},{value:"Source Code",id:"source-code",level:3},{value:"Enabling Rust Analyzer",id:"enabling-rust-analyzer",level:3},{value:"The Module",id:"the-module",level:2},{value:"Build the module",id:"build-the-module",level:2},{value:"Loading the module",id:"loading-the-module",level:2},{value:"Unload the module",id:"unload-the-module",level:2},{value:"Module Parameters",id:"module-parameters",level:2},{value:"Run Script",id:"run-script",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Bonus",id:"bonus",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"empty-module",children:"Empty Module"})}),"\n",(0,s.jsx)(n.p,{children:"The first exercise is to write an empty  module. The module will print a message when it loads and\na message when it is unloaded."}),"\n",(0,s.jsx)(n.h2,{id:"tree-structure",children:"Tree Structure"}),"\n",(0,s.jsx)(n.p,{children:"Kernel modules are split into two categories:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"in tree"})," - modules that reside within the kernel's source code tree"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"out of tree"})," - modules that are built outside the kernel"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["We will build out of tree modules. The folder structure of a kernel module is different from\nthe one of a program. The kernel uses its own tools to build the module, while applications\nuse ",(0,s.jsx)(n.code,{children:"cargo"}),". The kernel uses ",(0,s.jsx)(n.code,{children:"make"})," and ",(0,s.jsx)(n.code,{children:"Kbuild"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"kbuild-file",children:"Kbuild File"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Kbuild"})," file defines the object files that the module provides.\nIn our case, the object file will be called ",(0,s.jsx)(n.code,{children:"empty.o"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-makefile",children:"# SPDX-License-Identifier: GPL-2.0\n\nobj-m := empty.o\n"})}),"\n",(0,s.jsx)(n.h3,{id:"makefile",children:"Makefile"}),"\n",(0,s.jsxs)(n.p,{children:["We need to use a special ",(0,s.jsx)(n.code,{children:"makefile"})," that connects to the kernel's source build infrastructure."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-makefile",children:"# SPDX-License-Identifier: GPL-2.0\n\n# Ask the rust compiler to rewrite the file names that start with ../ to ./\n# when dispaying errors, warnings and notes.\n# \n# Example: ../source.rs will be displayed as source.rs\n# \n# This is needed as we use the ./build folder for compiling and the compiler\n# considers the source files to be in ../\nexport KRUSTFLAGS := --remap-path-prefix=../=\n\nKDIR ?= /lib/modules/`uname -r`/build\n\ndefault:\n\techo $$RUSTFLAGS\n\t$(MAKE) -C $(KDIR) LLVM=1 M=$$PWD MO=$$PWD/build\n\nclean:\n\t$(MAKE) -C $(KDIR) M=$$PWD MO=$$PWD/build clean\n\nrust-analyzer:\n\t$(MAKE) -C $(KDIR) M=$$PWD rust-analyzer\n\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This ",(0,s.jsx)(n.code,{children:"makefile"})," defines three important targets:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"default"})," - that build the module"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"clean"})," - that cleans the module"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"rust-analyzer"})," - that build the ",(0,s.jsx)(n.code,{children:"rust-project.json"})," file used by ",(0,s.jsx)(n.a,{href:"https://rust-analyzer.github.io/",children:"rust-analyzer"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"makefile"})," assumes that we will set the ",(0,s.jsx)(n.code,{children:"$KDIR"})," variable to point to the kernel's soutrce code. In our case, this\nvariable will be similar to ",(0,s.jsx)(n.code,{children:"../linux-6.18-rc5/"}),"."]}),"\n",(0,s.jsxs)(n.admonition,{type:"warning",children:[(0,s.jsxs)(n.p,{children:["Please make sure you export this variable before running any ",(0,s.jsx)(n.code,{children:"make"})," targets."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:'export KDIR="../linux-6.18-rc5"\n'})}),(0,s.jsxs)(n.p,{children:["You can allways define the variable in the ",(0,s.jsx)(n.code,{children:"make"})," command line: ",(0,s.jsx)(n.code,{children:"make KDIR=../linux-6.18-rc5 ..."}),"."]}),(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"KRUSTFLAGS"})]})]}),"\n",(0,s.jsx)(n.h3,{id:"source-code",children:"Source Code"}),"\n",(0,s.jsxs)(n.p,{children:["The main source code file of our module is ",(0,s.jsx)(n.code,{children:"empty.rs"}),". It has to have the same name ast the object file defined in\n",(0,s.jsx)(n.code,{children:"KBuild"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust"})}),"\n",(0,s.jsx)(n.h3,{id:"enabling-rust-analyzer",children:"Enabling Rust Analyzer"}),"\n",(0,s.jsxs)(n.p,{children:["To help us with code completion, we want to activate rust-analyzer. As this is not a standard rust application,\nwe have to run ",(0,s.jsx)(n.code,{children:"make rust-analyzer"})," to obtgain the ",(0,s.jsx)(n.code,{children:"rust-project.json"})," file which rust-analyzer can use\ninstead of ",(0,s.jsx)(n.code,{children:"Cargo.toml"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"the-module",children:"The Module"}),"\n",(0,s.jsxs)(n.p,{children:["Printing to the kernel console is done using the ",(0,s.jsx)(n.code,{children:"pr_*"})," macros such as\n",(0,s.jsx)(n.a,{href:"https://rust.docs.kernel.org/kernel/macro.pr_info.html",children:(0,s.jsx)(n.code,{children:"pr_info!"})}),",\n",(0,s.jsx)(n.a,{href:"https://rust.docs.kernel.org/kernel/macro.pr_error.html",children:(0,s.jsx)(n.code,{children:"pr_error!"})}),",\n",(0,s.jsx)(n.a,{href:"https://rust.docs.kernel.org/kernel/macro.pr_warn.html",children:(0,s.jsx)(n.code,{children:"pr_warn!"})}),",\n",(0,s.jsx)(n.a,{href:"https://rust.docs.kernel.org/kernel/macro.pr_debug.html",children:(0,s.jsx)(n.code,{children:"pr_debug!"})})," and\n",(0,s.jsx)(n.a,{href:"https://rust.docs.kernel.org/kernel/macro.pr_alert.html",children:(0,s.jsx)(n.code,{children:"pr_alert"})}),","]}),"\n",(0,s.jsxs)(n.p,{children:["A module is declared using the ",(0,s.jsx)(n.a,{href:"https://rust.docs.kernel.org/macros/macro.module.html",children:(0,s.jsx)(n.code,{children:"module!"})})," macro. It defines\nthe name, authors, description and the license of the module and the data type that implements the ",(0,s.jsx)(n.code,{children:"Module"})," and ",(0,s.jsx)(n.code,{children:"Drop"}),"\ntrais. In this exmple, this is the ",(0,s.jsx)(n.code,{children:"Empty"})," type."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Module::init"})," function may return an ",(0,s.jsx)(n.a,{href:"https://rust.docs.kernel.org/kernel/error/struct.Error.html",children:(0,s.jsx)(n.code,{children:"Error"})})," ",(0,s.jsx)(n.a,{href:"https://rust.docs.kernel.org/kernel/error/code/index.html",children:"code"})," if the module cannot be loaded. The kernel will try several times\nand print the error if it still fails."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// SPDX-License-Identifier: GPL-2.0\n\n//! Rust Empty Module\n\nuse kernel::prelude::*;\n\nmodule! {\n    type: Empty,\n    name: "empty",\n    authors: ["Rust Workshop"],\n    description: "Rust empty sample",\n    license: "GPL",\n}\n\nstruct Empty;\n\nimpl kernel::Module for Empty {\n    fn init(_module: &\'static ThisModule) -> Result<Self> {\n        pr_info!("Empty Module (init)\\n");\n\n        Ok(Empty)\n    }\n}\n\nimpl Drop for Empty {\n    fn drop(&mut self) {\n        pr_info!("Empty Module (exit)\\n");\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"build-the-module",children:"Build the module"}),"\n",(0,s.jsxs)(n.p,{children:["To build the module we use the ",(0,s.jsx)(n.code,{children:"make"})," command. This will build all the Rust code and all the necessary C glue code\nand output the kernel object file ",(0,s.jsx)(n.code,{children:"build/empty.ko"}),". This is actually a static relocatable ELF file."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shelll",children:"$ file build/empty.ko\nbuild/empty.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=b451eeb137ea43d0abda65ee315a5dd545d46e50, with debug_info, not stripped\n"})}),"\n",(0,s.jsx)(n.h2,{id:"loading-the-module",children:"Loading the module"}),"\n",(0,s.jsx)(n.p,{children:"To load the module into the kernel we have to perform the following steps:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["copy the ",(0,s.jsx)(n.code,{children:"empty.ko"})," in to ",(0,s.jsx)(n.code,{children:"$INIT_RAM_FS"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"../linux_kernel_development#build-ram-disk",children:"rebuild the RAM disk"})," so that it includes the module"]}),"\n",(0,s.jsx)(n.li,{children:"Boot the kernel"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The module will not be automatically loaded by the kernel, we have to load it manually using the ",(0,s.jsx)(n.code,{children:"insmod"})," command."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"$ insmod empty.ko \nempty: loading out-of-tree module taints kernel.\nempty: Empty Module (init)\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"If everything works, we should see the module's init message."}),"\n",(0,s.jsxs)(n.p,{children:["We can see the loaded module using ",(0,s.jsx)(n.code,{children:"lsmod"})," to list all the kernel modules."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"$ lsmod\nempty 12288 0 - Live 0xffffffffa0000000 (O)\n"})}),"\n",(0,s.jsx)(n.p,{children:"We can see here the address at which the module is loaded."}),"\n",(0,s.jsx)(n.h2,{id:"unload-the-module",children:"Unload the module"}),"\n",(0,s.jsxs)(n.p,{children:["Unloading a module is done by using the ",(0,s.jsx)(n.code,{children:"rmmod"})," command. It receives one single parameter that is the name\nof the module (without the ",(0,s.jsx)(n.code,{children:".ko"})," extension)."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"$ rmmod empty\nempty: Empty Module (exit)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["We should see the ",(0,s.jsx)(n.code,{children:"drop"})," message."]}),"\n",(0,s.jsx)(n.h2,{id:"module-parameters",children:"Module Parameters"}),"\n",(0,s.jsx)(n.p,{children:"Modules can receive parameters from the command line when loaded."}),"\n",(0,s.jsxs)(n.admonition,{type:"warning",children:[(0,s.jsxs)(n.p,{children:["The parameters API in Rust is not yet available in the mainstream kernel. We will have to use the ",(0,s.jsx)(n.code,{children:"next"})," version of the kernel."]}),(0,s.jsxs)(n.p,{children:["To download this version, please use ",(0,s.jsx)(n.code,{children:"git clone --depth 1 https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git"}),".\nTo compile this version with the same configuration, please copy the ",(0,s.jsx)(n.code,{children:".config"})," file from the stable kernel folder to\nthis kernel folder and run ",(0,s.jsx)(n.code,{children:"make -jn"})," where ",(0,s.jsx)(n.code,{children:"n"})," is replaced by the number of cores that your laptop has."]})]}),"\n",(0,s.jsxs)(n.p,{children:["Parameters are defined in the ",(0,s.jsx)(n.code,{children:"module!"})," macro using the ",(0,s.jsx)(n.code,{children:"params"})," filed."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'module! {\n    // ...\n    params: {\n        first_param: u8 {\n            default: 1,\n            description: "This parameter has a default of 1",\n        },\n    },\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"To read the value of a parameter, use"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"module_parameters::first_param.value()\n"})}),"\n",(0,s.jsxs)(n.p,{children:["where ",(0,s.jsx)(n.code,{children:"first_param"})," is the name of the parameter."]}),"\n",(0,s.jsxs)(n.p,{children:["Parameter values are assigned values when the module is loaded with ",(0,s.jsx)(n.code,{children:"insmod"}),". The synatx is:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"$ insmod module.ko parameter_1=value parameter_2=value ...\n"})}),"\n",(0,s.jsx)(n.h2,{id:"run-script",children:"Run Script"}),"\n",(0,s.jsx)(n.p,{children:"Every time we change the module, we have to perform the following steps:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Build the module"}),"\n",(0,s.jsxs)(n.li,{children:["Copy the driver to ",(0,s.jsx)(n.code,{children:"$INIT_RAM_FS"})]}),"\n",(0,s.jsx)(n.li,{children:"Rebuild the RAM disk"}),"\n",(0,s.jsx)(n.li,{children:"Run QEMU with the nu RAM disk"}),"\n",(0,s.jsx)(n.li,{children:"Load the module"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["We can use a ",(0,s.jsx)(n.code,{children:"run.sh"})," script like the following placed in the module's folder to automate this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'#!/bin/sh\n\nMODULE=empty.ko\nBUILD_DIR="$(pwd)/build"\n\nset -e\n\nif [ -z $KDIR ]; then\n    echo "Kernel folder not set, use export KDIR=..."\n    exit 1\nfi\n\nif [ -z $INIT_RAM_FS ]; then\n    echo "initramfs folder not set, use export INIT_RAM_FS=..."\n    ecit 1\nfi\n\necho "Building module"\nmake\n\necho "Kernel folder $KDIR"\necho "initramfs folder $INIT_RAM_FS"\n\nKVERSION=$(cd "$KDIR" && make kernelversion)\n\necho "Kernel version $KVERSION"\n\necho "Copying driver"\nMODULES_DIR="$INIT_RAM_FS/lib/modules/$KVERSION"\nmkdir -p "$MODULES_DIR"\ncp build/empty.ko "$MODULES_DIR"\n\necho "Compressing initramfs"\n(cd "$INIT_RAM_FS" && find . -print0 | cpio --null -ov --format=newc | gzip -9 > "$BUILD_DIR/initramfs.cpio.gz")\n\necho "Running QEMU"\nqemu-system-x86_64 -kernel "$KDIR/arch/x86_64/boot/bzImage" --initrd build/initramfs.cpio.gz -nographic -append "console=ttyS0" -s\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Make sure to export both ",(0,s.jsx)(n.code,{children:"$KDIR"})," and ",(0,s.jsx)(n.code,{children:"$INIT_RAM_FS"})," variables before running the script."]})}),"\n",(0,s.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Modify the ",(0,s.jsx)(n.code,{children:"Module::init"})," function to return an ",(0,s.jsx)(n.code,{children:"Error"}),". Try loading the module with different errors and see what the kernel prints."]}),"\n",(0,s.jsxs)(n.li,{children:["Modify the module to print several types of messages using different ",(0,s.jsx)(n.code,{children:"pr_*"})," and see what the kernel prints."]}),"\n",(0,s.jsxs)(n.li,{children:["Print the current process PID, current CPU ID and current user ID in the ",(0,s.jsx)(n.code,{children:"Module::init"})," function. (Hint: use the ",(0,s.jsx)(n.a,{href:"https://rust.docs.kernel.org/kernel/macro.current.html",children:(0,s.jsx)(n.code,{children:"current!"})})," macro and the ",(0,s.jsx)(n.a,{href:"https://rust.docs.kernel.org/kernel/task/struct.Task.html#method.current",children:(0,s.jsx)(n.code,{children:"Task"})})," structure."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"bonus",children:"Bonus"}),"\n",(0,s.jsxs)(n.p,{children:["Add two ",(0,s.jsx)(n.code,{children:"u8"})," parameters to the module and print their sum in the init message. Make sure you:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["boot the ",(0,s.jsx)(n.code,{children:"next"})," version of the kernel"]}),"\n",(0,s.jsxs)(n.li,{children:["set the correct ",(0,s.jsx)(n.code,{children:"$KDIR"})," path to the ",(0,s.jsx)(n.code,{children:"next"})," version of the kernel"]}),"\n",(0,s.jsxs)(n.li,{children:["run ",(0,s.jsx)(n.code,{children:"make rust-analyuzer"})," with the correct ",(0,s.jsx)(n.code,{children:"$KDIR"})," path pointing to the next version of the kernel"]}),"\n"]})]})}function a(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,l)=>{l.d(n,{R:()=>t,x:()=>d});var r=l(6540);const s={},i=r.createContext(s);function t(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);