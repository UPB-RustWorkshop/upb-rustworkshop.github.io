---
title: Rust Essentials
---

# üõ†Ô∏è Rust Essentials: The Foundation

**"Before we build the editor, we must calibrate our tools."**

This section covers the essential setup and the two specific concepts‚Äî**Error Handling** and **Pattern Matching**‚Äîthat are required to complete the upcoming tasks. We will establish a workflow that ensures memory safety without the manual overhead typical of older systems languages.

---

### **1. The Build System: Cargo**

In languages like C or C++, setting up a project often involves configuring build systems (Make, CMake) and package managers manually. Rust consolidates the compiler (`rustc`), build system, and dependency manager into a single tool: **Cargo**.

1.  **Verify Installation:**
    Open your terminal and run: `cargo --version`
2.  **Create a Sandbox Project:**
    We will create a temporary project to test our logic before adding it to the Tauri app.
    ```bash
    cargo new rust-warmup
    cd rust-warmup
    ```

### **2. The Concept: The `Result` Type**

In C or C++, system calls (like opening a file) often return an integer status code (e.g., `-1` for failure) or throw an exception. This requires the developer to remember to check that specific integer or wrap code in try/catch blocks.

Rust handles this differently to prevent undefined behavior. It uses the **`Result`** type.

A `Result` is an enum that contains **one** of two possible values:

- **`Ok(T)`**: The operation succeeded, containing the data (`T`).
- **`Err(E)`**: The operation failed, containing the error details (`E`).

You **cannot** access the data inside `Ok` without first handling the possibility of `Err`. This ensures that I/O errors are never silently ignored.

### **3. The Exercise: Safe File Reading**

Open `src/main.rs` in your `rust-warmup` folder. We will write a function that attempts to read a file that does not exist to demonstrate how Rust forces safety.

**Step 1: Import the filesystem module**

```rust
use std::fs;
```

**Step 2: Implement the Logic**
We will use **`match`**, which is similar to a `switch` statement in C++, but with a critical difference: it is **exhaustive**. The compiler will refuse to build your code if you do not handle every possible outcome (Success and Failure).

```rust
use std::fs;

fn main() {
    // Try to read a file that definitely doesn't exist
    let filename = "ghost_file.txt";

    // This call does NOT return a String.
    // It returns a Result<String, std::io::Error>
    let result = fs::read_to_string(filename);

    // We must 'unwrap' the Result to get the value
    match result {
        Ok(content) => {
            // This block executes ONLY if the OS successfully read the file
            println!("File content: {}", content);
        },
        Err(error) => {
            // This block executes if ANY system error occurred (Permission denied, Not found, etc.)
            // In C++, this might have caused a crash if not caught.
            println!("‚ö†Ô∏è  Error reading '{}'", filename);
            println!("System Message: {}", error);
        }
    }
}
```

### **4. Execution**

Run the project:

```bash
cargo run
```

**Expected Output:**

```text
‚ö†Ô∏è  Error reading 'ghost_file.txt'
System Message: The system cannot find the file specified. (os error 2)
```

### **Relevance to the Course**

In the upcoming Text Editor tasks, every interaction between your UI and the Operating System will follow this pattern:

1.  Attempt an OS action (Read/Write).
2.  Receive a `Result`.
3.  Match the result to send either **Data** or an **Error Message** back to the user.

**"Safety is not an option you enable; it is the default state of the language."**
_Ready? Let's build the editor._ üöÄ
