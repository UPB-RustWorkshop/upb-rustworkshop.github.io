---
title: The System Inspector
---

# Task 4: The System Inspector 

---

_"Reading the text is simple. Reading the system attributes is where engineering begins."_

In standard C/C++, accessing file metadata (size, permissions, timestamps) involves using the `stat` family of structs and system calls, which can vary significantly between Windows and Linux/macOS.

Rust abstracts this via `std::fs::metadata`, but introduces a new challenge: **Data Serialization**.

**Your Mission:** Add a "File Info" panel that displays system-level metadata for the currently open file.

---

### **1. The Concept: Struct Serialization**

To send a complex C-style struct from Rust to a JavaScript frontend, we cannot simply pass the memory address. We must serialize the data into a format the frontend understands (JSON).

Rust uses a standard crate for this called **Serde** (SERializer/DEserializer).

1.  Open `Cargo.toml` and add `serde` to your dependencies:
    ```toml
    [dependencies]
    serde = { version = "1.0", features = ["derive"] }
    # ... existing dependencies
    ```

### **2. Backend Challenge (Rust)**

You need to query the filesystem for metadata and map it to a struct.

**Requirements:**

1.  Define a Rust `struct` representing the file stats.
2.  Derive `Serialize` so Tauri can convert it to JSON automatically.
3.  Use `std::fs::metadata` to populate the data.

**Starter Code:**

```rust
use std::fs;
use serde::Serialize;

// This struct will be converted to a JSON object automatically
#[derive(Serialize)]
struct FileStats {
    size_bytes: u64,
    is_readonly: bool,
    // Challenge: 'modified' returns SystemTime, which is not directly serializable to JSON.
    // You must figure out how to convert SystemTime to a UNIX timestamp (u64) or String.
    last_modified: u64,
}

#[tauri::command]
fn get_file_stats(path: String) -> Result<FileStats, String> {
    // TODO:
    // 1. Call fs::metadata(&path)
    // 2. Handle the Result (match or ?)
    // 3. Map the Metadata struct to your FileStats struct
}
```

### **3. Frontend Challenge (TypeScript)**

1.  Create a "Properties" view or a footer bar in your editor.
2.  When a file is active, invoke `get_file_stats`.
3.  Display the size.
    - _Math Challenge:_ Convert the raw bytes into human-readable units (KB, MB, GB).

### **4. Deep Dive: The Time Problem**

In C++, `time_t` is usually just an integer. In Rust, `SystemTime` is an opaque type designed to be platform-independent.

- **The Hurdle:** You cannot send `SystemTime` directly to JS.
- **The Hint:** Look for `duration_since(UNIX_EPOCH)` in the Rust documentation to convert the time object into a simple number that JavaScript's `new Date()` can parse.

### **Conclusion Task 4**

Completing this task demonstrates mastery of:

1.  **System Abstraction:** Using `std::fs` to normalize OS-specific file attributes.
2.  **FFI (Foreign Function Interface):** Marshalling complex data structures between Rust and JS via Serde.

**"You now control not just the content, but the container."** ðŸ¦€âœ¨

---